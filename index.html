<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Falcon Run â€“ Asteroides & TIE</title>
  <style>
    :root{
      --bg1:#040510;
      --bg2:#08102a;
      --fg:#e9eef7;
      --muted:#9aa7bd;
      --accent:#7dd3fc;
      --laser:rgb(70,255,0);
    }
    *{box-sizing:border-box}
   html, body{
	  height: 100%;
	  touch-action: none;
	  overscroll-behavior: none;
		  -webkit-text-size-adjust: 100%;
	}

	body{
	  margin:0;
	  min-height: var(--appH, 100dvh);
	  padding-bottom: env(safe-area-inset-bottom);

	  display:grid;
	  place-items:center;

	  background:radial-gradient(1100px 650px at 25% 10%, #1a2a55 0%, var(--bg1) 60%, #02030a 100%);
	  color:var(--fg);
	  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
	  overflow:hidden;
	}

    .wrap{ width:min(980px, 96vw); user-select:none; }
    .hud{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      margin:0 0 10px 0; color:var(--muted); font-size:14px;
    }
	.hud-right{
	  display:flex;
	  align-items:center;
	  gap:10px;
	}
    .hud b{ color:var(--fg); }
    canvas{
      width:auto;
      height:auto;
      border-radius:16px;
      background:linear-gradient(var(--bg2), var(--bg1) 65%);
      box-shadow: 0 20px 80px rgba(0,0,0,.45);
      outline: 1px solid rgba(255,255,255,.08);
      display:block;
      touch-action: none;
    }
    .hint{ margin-top:10px; color:var(--muted); font-size:13px; line-height:1.35; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      background:rgba(255,255,255,.06);
      outline:1px solid rgba(255,255,255,.08);
    }
        .dot{
      width:8px; height:8px; border-radius:50%;
      background:var(--accent);
      box-shadow:0 0 0 4px rgba(125,211,252,.15);
    }

    /* ðŸ”Š BotÃ³n mÃºsica ON/OFF */
	#musicToggle{
	  font-size: 16px;
	  padding: 4px 8px;
	  border-radius: 8px;
	  border: none;

	  background: rgba(255,255,255,.08);
	  color: var(--fg);
	  cursor: pointer;

	  line-height: 1;
	  user-select: none;
	}
	#musicToggle:hover{
	  background: rgba(255,255,255,.14);
	}
	#musicToggle:active{
	  transform: scale(0.95);
	}


  </style>
</head>
<body>
  <div class="wrap">
   <div class="hud">
	  <div class="pill">
		<span class="dot"></span>
		<span>Impulso con <b>Espacio</b> o <b>Click</b></span>
	  </div>

	  <div class="hud-right">
		<span>Puntos: <b id="score">0</b> Â· RÃ©cord: <b id="best">0</b></span>
		<button id="musicToggle" aria-label="MÃºsica">ðŸ”Š</button>
	  </div>
	</div>


    <canvas id="c" width="960" height="440"></canvas>
	
  </div>

<script>
(() => {

   const canvas = document.getElementById("c");

  // === FIT REAL EN iOS (que se vea ENTERO en landscape) ===
  const BASE_W = 960, BASE_H = 440;

  function getVisibleSize(){
    const vv = window.visualViewport;
    const w = Math.floor(vv ? vv.width  : window.innerWidth);
    const h = Math.floor(vv ? vv.height : window.innerHeight);
    return { w, h };
  }

  function fitGameToScreen(){
    const { w, h } = getVisibleSize();

    // alto real visible (para tu body/min-height actual)
    document.documentElement.style.setProperty("--appH", `${h}px`);

    const MAX_CSS_W = 980; // como tu max-width anterior
	const scale = Math.min(
	  MAX_CSS_W / BASE_W, // no crecer mÃ¡s de 980px de ancho
	  w / BASE_W,         // no salirse por ancho visible
	  h / BASE_H          // no salirse por alto visible
	);

    const cssW = Math.floor(BASE_W * scale);
    const cssH = Math.floor(BASE_H * scale);

    canvas.style.width  = cssW + "px";
    canvas.style.height = cssH + "px";
  }

	fitBurst();
	window.addEventListener("resize", fitBurst, { passive: true });
	window.addEventListener("orientationchange", fitBurst, { passive: true });
	if (window.visualViewport){
	  window.visualViewport.addEventListener("resize", fitBurst, { passive: true });
	  window.visualViewport.addEventListener("scroll", fitBurst, { passive: true });
	}


  // === BLOQUEO DE ZOOM: DESPUÃ‰S de haber encajado la pantalla ===
  let zoomLocked = false;
  function lockZoomNow(){
    if (zoomLocked) return;
    zoomLocked = true;

    // Pinch zoom en iOS
    ["gesturestart","gesturechange","gestureend"].forEach(ev => {
      document.addEventListener(ev, e => e.preventDefault(), { passive:false });
    });

    // Doble-tap zoom
    let lastTouchEnd = 0;
    document.addEventListener("touchend", (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive:false });

    // Evita scroll/zoom al tocar el canvas
    canvas.addEventListener("touchstart", e => e.preventDefault(), { passive:false });
    canvas.addEventListener("touchmove",  e => e.preventDefault(), { passive:false });
  }

  // En el primer input real del usuario: re-fit (por si Safari moviÃ³ barras) y bloquea zoom
	window.addEventListener("pointerdown", () => {
	  fitBurst();
	  lockZoomNow();
	}, { once:true, passive:true });


function fitBurst(){
  fitGameToScreen();
  requestAnimationFrame(fitGameToScreen);
  setTimeout(fitGameToScreen, 50);
  setTimeout(fitGameToScreen, 150);
  setTimeout(fitGameToScreen, 300);
}


// ======= LETRAS PIXELADAS  ==========

// --- Pixel text (bitmap 5x7) ---
const PIX5x7 = {
  " ": ["00000","00000","00000","00000","00000","00000","00000"],
  "!": ["00100","00100","00100","00100","00100","00000","00100"],
  ".": ["00000","00000","00000","00000","00000","00100","00100"],
  ":": ["00000","00100","00100","00000","00100","00100","00000"],
  "-": ["00000","00000","00000","11111","00000","00000","00000"],
  "Â·": ["00000","00000","00000","00100","00000","00000","00000"], // punto medio
  "/": ["00001","00010","00100","01000","10000","00000","00000"],
    "%":["11001","11010","00100","01000","10110","00110","00000"],

  "0": ["01110","10001","10011","10101","11001","10001","01110"],
  "1": ["00100","01100","00100","00100","00100","00100","01110"],
  "2": ["01110","10001","00001","00010","00100","01000","11111"],
  "3": ["11110","00001","00001","01110","00001","00001","11110"],
  "4": ["00010","00110","01010","10010","11111","00010","00010"],
  "5": ["11111","10000","11110","00001","00001","10001","01110"],
  "6": ["00110","01000","10000","11110","10001","10001","01110"],
  "7": ["11111","00001","00010","00100","01000","01000","01000"],
  "8": ["01110","10001","10001","01110","10001","10001","01110"],
  "9": ["01110","10001","10001","01111","00001","00010","01100"],

  "A": ["01110","10001","10001","11111","10001","10001","10001"],
  "B": ["11110","10001","10001","11110","10001","10001","11110"],
  "C": ["01110","10001","10000","10000","10000","10001","01110"],
  "D": ["11100","10010","10001","10001","10001","10010","11100"],
  "E": ["11111","10000","10000","11110","10000","10000","11111"],
  "F": ["11111","10000","10000","11110","10000","10000","10000"],
  "G": ["01110","10001","10000","10111","10001","10001","01110"],
  "H": ["10001","10001","10001","11111","10001","10001","10001"],
  "I": ["01110","00100","00100","00100","00100","00100","01110"],
  "J": ["00111","00010","00010","00010","00010","10010","01100"],
  "K": ["10001","10010","10100","11000","10100","10010","10001"],
  "L": ["10000","10000","10000","10000","10000","10000","11111"],
  "M": ["10001","11011","10101","10101","10001","10001","10001"],
  "N": ["10001","11001","10101","10011","10001","10001","10001"],
  "O": ["01110","10001","10001","10001","10001","10001","01110"],
  "P": ["11110","10001","10001","11110","10000","10000","10000"],
  "Q": ["01110","10001","10001","10001","10101","10010","01101"],
  "R": ["11110","10001","10001","11110","10100","10010","10001"],
  "S": ["01111","10000","10000","01110","00001","00001","11110"],
  "T": ["11111","00100","00100","00100","00100","00100","00100"],
  "U": ["10001","10001","10001","10001","10001","10001","01110"],
  "V": ["10001","10001","10001","10001","10001","01010","00100"],
  "W": ["10001","10001","10001","10101","10101","10101","01010"],
  "X": ["10001","10001","01010","00100","01010","10001","10001"],
  "Y": ["10001","10001","01010","00100","00100","00100","00100"],
  "Z": ["11111","00001","00010","00100","01000","10000","11111"],
};

function drawPixelText(ctx, text, x, y, scale, color, align="left"){
  text = (text ?? "").toUpperCase();

  // Acepta 'Â¡' como '!' (por si lo usas en el mensaje)
  text = text.replaceAll("Â¡","!");

  const charW = 5, charH = 7, gap = 1;
  const lineW = (charW + gap) * scale;

  let startX = x;
  if (align === "center"){
    startX = x - Math.floor((text.length * lineW - gap*scale) / 2);
  } else if (align === "right"){
    startX = x - (text.length * lineW - gap*scale);
  }

  ctx.save();
  ctx.imageSmoothingEnabled = false;

  // --- DEBUG: hitboxes (tecla H) ---
  let debugHitboxes = false;
  ctx.fillStyle = color;

  let cx = startX;
  for (let i=0; i<text.length; i++){
    const ch = text[i];
    const glyph = PIX5x7[ch] || PIX5x7[" "];
    for (let row=0; row<charH; row++){
      const bits = glyph[row];
      for (let col=0; col<charW; col++){
        if (bits[col] === "1"){
          ctx.fillRect(cx + col*scale, y + row*scale, scale, scale);
        }
      }
    }
    cx += lineW;
  }
  ctx.restore();
}



function drawPhaseMsgPixel(ctx, title, subtitle, y){
  // Ajusta tamaÃ±o (scale) segÃºn lo grande que quieras el texto
  const s1 = 4; // tÃ­tulo
  const s2 = 3; // subtÃ­tulo

  // sombra (1px â€œpixelâ€)
  drawPixelText(ctx, title,   W/2 + s1, y + s1, s1, "rgba(0,0,0,0.45)", "center");
  drawPixelText(ctx, title,   W/2,      y,      s1, "#E8ECF8",         "center");

  if (subtitle){
    const y2 = y + (7*s1) + 10;
    drawPixelText(ctx, subtitle, W/2 + s2, y2 + s2, s2, "rgba(0,0,0,0.45)", "center");
    drawPixelText(ctx, subtitle, W/2,      y2,      s2, "rgba(232,236,248,0.85)", "center");
  }
}

function centerPixelText(text, scale, yOffset, color){
  // ajuste global vertical (sube todo el texto)
  const GLOBAL_Y_SHIFT = -100;   // prueba -6, -8 o -10

  const y = (H/2 + GLOBAL_Y_SHIFT + (yOffset|0)) | 0;

  // sombra fina 1px
  const sh = 1;

  drawPixelText(
    ctx,
    text,
    ((W/2)|0) + sh,
    (y + sh)|0,
    scale,
    "rgba(0,0,0,0.45)",
    "center"
  );

  drawPixelText(
    ctx,
    text,
    (W/2)|0,
    y,
    scale,
    color,
    "center"
  );
}


// --- NUEVAS VARIABLES DE ESCUDO ---
let shields = 2;       // 2 = Lleno, 1 = DaÃ±ado, 0 = Sin escudo
let invulTimer = 0;    // Tiempo de gracia tras impacto
// Aviso cuando pierdes un escudo (texto pixel)
let shieldMsg = "";
let shieldT = 0;
let shieldDur = 0;


	// ===== AUDIO =====
	let musicStarted = false;
	let audioUnlocked = false;
	let audioUnlockPromise = null;
	let laserCtx = null;
	let laserBuf = null;
	let laserGain = null;
	let crashBuf = null;
	let sfxGain = null;  // ganancia para FX

	//let musicEnabled = true;
	let audioEnabled = localStorage.getItem("audioEnabled") !== "false";
	
	async function initLaserWebAudio(){
	  if (laserCtx) return true;

	  // En file:// fetch de audio da CORS en Chrome/iOS; salimos sin audio
	  if (location.protocol === "file:") return false;

	  try{
		laserCtx = new (window.AudioContext || window.webkitAudioContext)();

		// Ganancia general para FX (laser + crash)
		sfxGain = laserCtx.createGain();
		sfxGain.gain.value = 0.75;
		sfxGain.connect(laserCtx.destination);

		// Ganancia especÃ­fica del lÃ¡ser
		laserGain = laserCtx.createGain();
		laserGain.gain.value = 0.45;
		laserGain.connect(sfxGain);

		const load = async (url) => {
		  try{
			const res = await fetch(url, { cache: "no-store" });
			if (!res.ok) throw new Error("HTTP " + res.status);
			const arr = await res.arrayBuffer();
			return await laserCtx.decodeAudioData(arr);
		  } catch(e){
			return null;
		  }
		};

		// Cargamos ambos buffers (lÃ¡ser y explosiÃ³n)
		const bufs = await Promise.all([
		  load("audio/8-bit-laser.mp3"),
		  load("audio/8-bit-explosion.mp3")
		]);

		laserBuf = bufs[0];
		crashBuf = bufs[1];

		// Si no se pudo cargar nada, apagamos WebAudio para no dejar ctx â€œcolgadoâ€
		if (!laserBuf && !crashBuf){
		  try { await laserCtx.close(); } catch(e){}
		  laserCtx = null;
		  return false;
		}

		return true;
	  } catch(e){
		// Si algo falla, no dejamos el juego roto
		try { if (laserCtx) await laserCtx.close(); } catch(_e){}
		laserCtx = null;
		laserBuf = null;
		crashBuf = null;
		return false;
	  }
	}



	function saveAudioPref(){
	  localStorage.setItem("audioEnabled", audioEnabled);
	}


	const sfxCrash = new Audio("audio/8-bit-explosion.mp3");
	sfxCrash.volume = 0.9;

	const sfxLaser = new Audio("audio/8-bit-laser.mp3");
	sfxLaser.volume = 0.6;

	const music = new Audio("audio/8-bit-music.mp3");
	music.loop = true;
	music.volume = 0.20;

	// ---- BotÃ³n mÃºsica ----
	const musicBtn = document.getElementById("musicToggle");

	function updateMusicIcon(){
	  musicBtn.textContent = audioEnabled ? "ðŸ”Š" : "ðŸ”‡";
	}

	musicBtn.addEventListener("click", () => {
	  unlockAudio().then(() => {
		audioEnabled = !audioEnabled;
		saveAudioPref();
		updateMusicIcon();

		if (!audioEnabled){
		  stopMusic();
		} else if (!gameOver && running){
		  musicStarted = true;
		  startMusic();
		}
	  });
	});


	updateMusicIcon();



	
function startMusic(){
  //if (!musicEnabled) return;
  if (!audioEnabled) return;
  if (!audioUnlocked) return;
  if (!music.paused) return;

  music.currentTime = 0;
  music.play().catch(()=>{});
}


function stopMusic(){
  if (!music.paused) music.pause();
}



  // --- HALCÃ“N: tu imagen embebida (con fondo transparente) ---
// --- HALCÃ“N: PNG embebido (tu imagen) + fondo negro transparente ---
	const falconImg = new Image();
	falconImg.src = "data:image/png;base64,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"

// --- PLANETA DE FONDO (fijo, difuso) ---
const bgPlanetImg = new Image();
bgPlanetImg.decoding = "async";
let bgPlanetReady = false;
bgPlanetImg.onload = () => { bgPlanetReady = true; };
bgPlanetImg.src = "data:image/png;base64,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JBCToqcc2XfVPL9UzgZcNDf6ika/15BmA7LggLfsrCPv0plz6vKdQuTC5mSSxvER/eLXLyda69vA19Y1U+O7uxlNbIBB3DrR3QIuAu+v58b/vXLhjooLah5TI81NtVhQz1PZtb0jPapKc0stjY01ADpxyljOu+gjhMMNiFh++OWr3veV7zQGud3ob2OV0lTt0c369/9a9+ImAMft87yPLOgqfJgJrF3zACds0nGRWsexidwNDDHWPeWO1duoQnikqo6sAspRxzUwbVbB9uBA0IbmGsZOmEUkOq6a7ak2FA11K1PAV6BuVZqAyom1oz1G5954elTOfovasbePjjZfMy0SdkD9kUwVNjzXvi6ucyqTTQVgIE/F/Tfps7uk/h9PrNoGcBZw7qduLlLgas6AblgZnFwl7qYCYk2LIIoLh4dhfhpVfHAOUUm2Pe4gyio60tjAU0rtYQ3KX1fuTyG1czpKOeeyiHXtW449JJqQwwBMhHBjkkDZmUWc3/3pT87dQmcljZgdYvcRH/n3OJGUfdvqJ//Bz/57MZ6r7uP3tfcqP6ikvFGBv/95x93rXwxUMrng8Nk9csmCKQB0dyaX/+rnHa2e36cXHju3lze8fXJBJlXDv/77655+5eWl/k9VEZH0MffW/jTwTcPLSWP39th312yb0KcSElV7Qp32XPzYRw6HKBDHPwLEuez7v6r7RzeBM2EbTOhTaQGwYdN7zilj/kgVXGyWRaw1ao6dYHi3AuIW11tQVH64lzMrbUSLoefeRDxGna885V562k3RNfza6mheaQ2M69a+OP76Lk4PSntp3UuPfTIl2ZRXNva+vo3XtluaREV3Pb3+4Q+8oUihp573br3tiXenf2reMRta5HzAtHh8D7/52TW07e7xL1x5vMjEgretnqezldBEwwlBzezx5MQe0WNFAddu2/5K121TOMYMdYOhBDH4U7/LwB1zENWBjkLxnwYAVVVHTNoALP+PlN2iv2uQFl0N3et28ZH16+eGeKVLeaExFLLlB5IQ/19/p2d76suy2xQBk1KfCqND8MH6aka26EtLu3ktCethLdgAiZqqEo64AKJqv+qpSWjeAib1nj1IYBzXX8SZqomugon1vHNDL17QelWdoZFIXJuEGii9Q2UVs8byZg9qcxNAEO9oo4sjQp8Cy8+ctZQ7V38fEYOIEK0ZU62HelUg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"

let falconReady = false;
falconImg.onload = () => { falconReady = true; };

const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

const scoreEl = document.getElementById("score");
const bestEl  = document.getElementById("best");

const W = canvas.width, H = canvas.height;

// ========= Reset CANVAS ==========
function resetLowCanvasesHard(){
  // reset total del estado interno (clip/transform/etc)
  groundLow.width = groundLow.width;
  groundLow.height = groundLow.height;
  gctx.imageSmoothingEnabled = false;

  ceilingLow.width = ceilingLow.width;
  ceilingLow.height = ceilingLow.height;
  cctx.imageSmoothingEnabled = false;

  // obliga a reconstruir el pattern
  groundPatternLow = null;
}




  // --- FX: explosiÃ³n + shake ---
const particles = [];

// --- FX extra: restos de asteroide y chatarra TIE (al chocar con escudo) ---
const debris = [];    // trozos de asteroide
const tieWrecks = []; // mitades de TIE
let shakeT = 0;
let shakeAmp = 0;
let flashT = 0;
let canRestart = true;
let restartTimer = 0;
// --- Fases / avisos en pantalla ---
let phaseMsg = "";
let phaseT = 0;
let phaseDur = 0;
let phase2Shown = false;


// --- FASE 3 / TransiciÃ³n a tÃºnel ---
const PHASE3_UNLOCK_DIST = 12000; // ajusta a tu gusto
// --- OndulaciÃ³n extra del tÃºnel (fase 3) ---
const TUNNEL_WAVE_AMP1 = 80;   // px (ajusta)
const TUNNEL_WAVE_LEN1 = 620;  // px (ajusta)
const TUNNEL_WAVE_AMP2 = 20;   // px
const TUNNEL_WAVE_LEN2 = 220;  // px

// Score extra por fase 3 (distancia)
const PHASE3_SCORE_PER_1000PX = 1; // 3 puntos por cada 1000px recorridos (ajusta)
let phase3ScoreCarry = 0;           // acumulador para no sumar decimales sin control


let phase3 = false;
let enteringPhase3 = false;

let spawnAsteroids = true;
let spawnTies = true;

// offset vertical del suelo/techo durante la transiciÃ³n (en px)
let floorOffsetY = 0;
let ceilingOffsetY = 0;

// progreso 0..1 de la transiciÃ³n
let tunnelT = 0;
let tunnelDuration = 6; // segundos (ajusta)

// --- Estrechamiento progresivo del tÃºnel (FASE 3) ---
let phase3StartX = 0;

// gap inicial y final (HALF GAP = mitad del hueco)
const TUNNEL_HALF_GAP_START = 200; // el que te gustaba al entrar (ajusta)
const TUNNEL_HALF_GAP_END   = 80;  // lo estrecho al final (ajusta)

// distancia (en "worldX") para pasar de START -> END
const TUNNEL_NARROW_DIST = 10000;   // cuanto mÃ¡s alto, mÃ¡s lento estrecha


// geometrÃ­a objetivo del tÃºnel
function tunnelCenterY(){ return H * 0.52; }
function tunnelHalfGap(){
  // Durante la transiciÃ³n, mantenemos el hueco inicial (para que sea justo al entrar)
  if (enteringPhase3) return TUNNEL_HALF_GAP_START;

  // En fase 3, se va estrechando segÃºn el avance
  if (phase3){
    const t = clamp((worldX - phase3StartX) / TUNNEL_NARROW_DIST, 0, 1);
    const k = easeInOut(t);

    // gap objetivo
    let half = lerp(TUNNEL_HALF_GAP_START, TUNNEL_HALF_GAP_END, k);

    // seguridad: evita hacerlo imposible (ajusta el multiplicador si quieres mÃ¡s/menos margen)
    const minHalf = Math.max(48, ship.r * 5);
    if (half < minHalf) half = minHalf;

    // snap al grid low-res
    half = Math.round(half / LOW_SCALE) * LOW_SCALE;
    return half;
  }

  // fuera de fase 3
  return TUNNEL_HALF_GAP_START;
}



function tunnelWaveY(xPx){
  // mismo scroll snapeado que el low-res para evitar temblores
  const scrollPx = worldX * 0.60;
  const snappedScrollPx = Math.floor(scrollPx / LOW_SCALE) * LOW_SCALE;

  const u = xPx + snappedScrollPx;  // âœ… xPx, no "x"

  let y =
    Math.sin(u / TUNNEL_WAVE_LEN1) * TUNNEL_WAVE_AMP1 +
    Math.sin(u / TUNNEL_WAVE_LEN2) * TUNNEL_WAVE_AMP2;

  // snap para look pixel perfect
  y = Math.round(y / LOW_SCALE) * LOW_SCALE;
  return y;
}

function tunnelWaveFactor(){
  if (phase3) return 1;
  if (enteringPhase3) return easeInOut(tunnelT); // 0â†’1 segÃºn se forma el tÃºnel
  return 0;
}


// easing suave
function easeInOut(t){
  return (t < 0.5) ? 2*t*t : 1 - Math.pow(-2*t + 2, 2)/2;
}

function showPhase(msg, dur=2.6){
	phaseMsg = msg;
	phaseDur = dur;
	phaseT = dur;
}



  
 
/// --- Planeta / suelo recto pero rocoso ---
const GROUND_Y = H - 34;     // altura del suelo (sube/baja)
const ROCK_AMP = 7;          // â€œrugosidadâ€ del borde (3â€“10)
const ROCK_STEP = 12;        // anchura de â€œpiedrasâ€ (8â€“18)


const TIE_UNLOCK_DIST = 6000; // px de worldX; ajusta (4000â€“9000)

// borde rocoso determinista (no aleatorio cada frame)
function rockEdgeAt(ix){
  // ix es un Ã­ndice de segmento
  // combinaciÃ³n simple de senos -> irregular, estable y barata
  return (
    Math.sin(ix * 1.7 + 0.9) * 0.55 +
    Math.sin(ix * 0.73 + 2.1) * 0.35 +
    Math.sin(ix * 0.31 + 0.2) * 0.20
  ) * ROCK_AMP;
}

function groundY(x){
  // Scroll del terreno (mismo factor que ya usas)
  const scroll = worldX * 0.60;

  // Ãndice "granular" para el serrucho/roca
  const ix = Math.floor((x + scroll) / ROCK_STEP);

  // --- OpciÃ³n 3: macro-ondulaciÃ³n con mesetas ---
  const WAVE_LEN = 520;  // 400â€“800 (mÃ¡s grande = ondas mÃ¡s largas)
  const WAVE_AMP = 20;   // 16â€“30  (mÃ¡s grande = mÃ¡s ondulaciÃ³n)
  const TERRACE  = 8;    // 4â€“8    (mÃ¡s grande = escalones mÃ¡s marcados)

  // Onda larga
  let wave = Math.sin((x + scroll) / WAVE_LEN) * WAVE_AMP;

  // Convertir a "terrazas"
  wave = Math.round(wave / TERRACE) * TERRACE;

  // Combinar: base + granularidad + onda
  let y = GROUND_Y + rockEdgeAt(ix) + wave;

  // Snap final al pixel-grid del suelo (con LOW_SCALE=3 queda perfecto)
  y = Math.round(y / LOW_SCALE) * LOW_SCALE;

  return y;
}

// --- Techo rocoso (similar al suelo, pero desde arriba) ---
function ceilingY(x){
  const scroll = worldX * 0.60;
  const ix = Math.floor((x + scroll) / ROCK_STEP);

  const WAVE_LEN = 520;
  const WAVE_AMP = 20;
  const TERRACE  = 8;

  let wave = Math.sin((x + scroll) / WAVE_LEN) * WAVE_AMP;
  wave = Math.round(wave / TERRACE) * TERRACE;

  let y = 34 + (rockEdgeAt(ix) * 0.9) + (wave * 0.6);

  y = Math.round(y / LOW_SCALE) * LOW_SCALE;
  return y;
}


// --- Suelo/techo efectivos (con offsets durante fase 3) ---
function floorYEff(x){
  const w = (enteringPhase3 || phase3) ? tunnelWaveY(x) * tunnelWaveFactor() : 0;
  return groundY(x) + floorOffsetY + w;
}

function ceilingYEff(x){
  const w = (enteringPhase3 || phase3) ? tunnelWaveY(x) * tunnelWaveFactor() : 0;
  return ceilingY(x) + ceilingOffsetY + w;
}




// --- Suelo estilo meteorito: textura tileable con crÃ¡teres (pixel art) ---
let groundTile = null;
let groundPattern = null;
const GROUND_TILE_W = 512;
const GROUND_TILE_H = 220;

// paleta (misma familia que meteoritos)
const G = {
  deep: "#0b1020",
  base: "#2a3242",
  mid:  "#3b4558",
  hi:   "#5f6878"
};

const laserPool = Array.from({length: 5}, () => {
  const a = new Audio("audio/8-bit-laser.mp3");
  a.volume = 0.6;
  return a;
});
let laserIdx = 0;

let lastLaserSfx = 0;

function playLaser(){
  if (!audioUnlocked || !audioEnabled) return;

  const now = performance.now();
  if (now - lastLaserSfx < 120) return;
  lastLaserSfx = now;

  if (laserCtx && laserBuf){
    const src = laserCtx.createBufferSource();
    src.buffer = laserBuf;
    src.connect(laserGain);
    src.start(0);
    return;
  }

  // fallback
  const a = laserPool[laserIdx];
  laserIdx = (laserIdx + 1) % laserPool.length;
  a.currentTime = 0;
  a.play().catch(()=>{});
}

function playCrash(){
  if (!audioUnlocked || !audioEnabled) return;

  if (laserCtx && crashBuf){
    const src = laserCtx.createBufferSource();
    src.buffer = crashBuf;
    src.connect(sfxGain);
    src.start(0);
    return;
  }

  // fallback por si aÃºn no cargÃ³
  sfxCrash.currentTime = 0;
  sfxCrash.play().catch(()=>{});
}



// --- Suelo PIXEL REAL (simple, sin crÃ¡teres/rocas) ---
const LOW_SCALE = 3; // 2-4: mÃ¡s bajo = mÃ¡s suave, mÃ¡s alto = mÃ¡s retro

let lowW = Math.max(1, Math.floor(W / LOW_SCALE));
let lowH = Math.max(1, Math.floor(H / LOW_SCALE));

const groundLow = document.createElement("canvas");
groundLow.width = lowW;
groundLow.height = lowH;
const gctx = groundLow.getContext("2d");
gctx.imageSmoothingEnabled = false;

let groundPatternLow = null;

// --- Techo low-res para el tÃºnel ---
const ceilingLow = document.createElement("canvas");
ceilingLow.width = lowW;
ceilingLow.height = lowH;
const cctx = ceilingLow.getContext("2d");
cctx.imageSmoothingEnabled = false;


function ensureGroundLow(){
  const nw = Math.max(1, Math.floor(W / LOW_SCALE));
  const nh = Math.max(1, Math.floor(H / LOW_SCALE));
    if (nw !== lowW || nh !== lowH){
    lowW = nw; lowH = nh;

    groundLow.width = lowW;
    groundLow.height = lowH;
    gctx.imageSmoothingEnabled = false;

    ceilingLow.width = lowW;
    ceilingLow.height = lowH;
    cctx.imageSmoothingEnabled = false;

    groundPatternLow = null;
  }

  if (!groundPatternLow) buildGroundPatternLow();
}

function buildGroundPatternLow(){
  const pat = document.createElement("canvas");
  pat.width = 32;
  pat.height = 32;
  const p = pat.getContext("2d");
  p.imageSmoothingEnabled = false;

  // base
  p.fillStyle = G.base;
  p.fillRect(0,0,32,32);

  // dither / granulado
  p.fillStyle = G.mid;
  for (let i=0; i<70; i++){
    p.fillRect((Math.random()*32)|0, (Math.random()*32)|0, 1, 1);
  }

  // puntos mÃ¡s oscuros
  p.fillStyle = G.deep;
  for (let i=0; i<30; i++){
    p.fillRect((Math.random()*32)|0, (Math.random()*32)|0, 1, 1);
  }

  // highlight sutil
  p.fillStyle = "rgba(255,255,255,0.06)";
  for (let i=0; i<18; i++){
    p.fillRect((Math.random()*32)|0, (Math.random()*32)|0, 1, 1);
  }

  groundPatternLow = gctx.createPattern(pat, "repeat");
}

function drawCeilingSurface(){
  ensureGroundLow();
  cctx.clearRect(0, 0, lowW, lowH);

  const scrollPx = worldX * 0.60;
  const snappedScrollPx = Math.floor(scrollPx / LOW_SCALE) * LOW_SCALE;
  const oxLow = (snappedScrollPx / LOW_SCALE) | 0;

  // y del techo en pixeles (canvas grande)
  function ceilingYLocal(xPx){
    const ix = Math.floor((xPx + snappedScrollPx) / ROCK_STEP);

    const WAVE_LEN = 520;
    const WAVE_AMP = 20;
    const TERRACE  = 8;

    let wave = Math.sin((xPx + snappedScrollPx) / WAVE_LEN) * WAVE_AMP;
    wave = Math.round(wave / TERRACE) * TERRACE;

    let y = 34 + (rockEdgeAt(ix) * 0.9) + (wave * 0.6) + ceilingOffsetY;
    if (enteringPhase3 || phase3) y += tunnelWaveY(xPx) * tunnelWaveFactor();


    y = Math.round(y / LOW_SCALE) * LOW_SCALE;
    return y;
  }

  // conversiÃ³n a coordenadas low-res
  function cyLow(xLow){
    const xPx = xLow * LOW_SCALE;
    return Math.floor(ceilingYLocal(xPx) / LOW_SCALE);
  }

  // silueta: desde arriba hasta el techo
  cctx.beginPath();
  cctx.moveTo(0, 0);
  cctx.lineTo(0, cyLow(0));
  for (let x = 1; x <= lowW; x++){
    cctx.lineTo(x, cyLow(x));
  }
  cctx.lineTo(lowW, 0);
  cctx.closePath();

  cctx.fillStyle = G.deep;
  cctx.fill();

  // textura (reusa groundPatternLow)
	const oyLow = (Math.floor(ceilingOffsetY / LOW_SCALE)) | 0;
	cctx.save();
	cctx.setTransform(1,0,0,1,0,0); // â† evita acumulaciones raras en iOS
	cctx.clip();
	// scroll del pattern en X e Y (Y sigue el movimiento del techo)
	cctx.translate(-oxLow, oyLow);
	cctx.fillStyle = groundPatternLow;
	// mÃ¡s grande para cubrir el desplazamiento en Y
	cctx.fillRect(oxLow, -lowH, lowW + oxLow + 2, lowH * 3);

	cctx.restore();


 // techo: borde / rim-light
	const step = 1; // o 2 para rendimiento
	const w = step;

	for (let x = 0; x <= lowW; x += step){
	  const y = cyLow(x);

	  // rim-light hacia el aire (ABAJO del borde)
	  cctx.fillStyle = "rgba(60,120,220,0.35)";
	  if (y + 1 < lowH) cctx.fillRect(x, y + 1, w, 1);

	  cctx.fillStyle = "rgba(40,90,170,0.25)";
	  if (y + 2 < lowH) cctx.fillRect(x, y + 2, w, 1);

	  // borde claro (opcional)
	  //cctx.fillStyle = "rgba(150,160,178,0.75)";
	  //cctx.fillRect(x, y, w, 1);
	}



  // upscale al canvas principal
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(ceilingLow, 0, 0, lowW, lowH, 0, 0, W, H);
  ctx.restore();
}




function drawPlanetSurface(){
  ensureGroundLow();
  gctx.clearRect(0, 0, lowW, lowH);

  // MISMO scroll para contorno y relleno (evita â€œbaileâ€)
  const scrollPx = worldX * 0.60;
  const snappedScrollPx = Math.floor(scrollPx / LOW_SCALE) * LOW_SCALE;
  const oxLow = (snappedScrollPx / LOW_SCALE) | 0;

  function groundYLocal(xPx){
  const ix = Math.floor((xPx + snappedScrollPx) / ROCK_STEP);

  // --- Macro ondulaciÃ³n con mesetas ---
  const WAVE_LEN = 520;
  const WAVE_AMP = 20;
  const TERRACE  = 8;

  let wave = Math.sin((xPx + snappedScrollPx) / WAVE_LEN) * WAVE_AMP;
  wave = Math.round(wave / TERRACE) * TERRACE;

  let y = GROUND_Y + rockEdgeAt(ix) + wave + floorOffsetY;
  if (enteringPhase3 || phase3) y += tunnelWaveY(xPx) * tunnelWaveFactor();

  y = Math.round(y / LOW_SCALE) * LOW_SCALE;
  return y;
}


  function gyLow(xLow){
    const xPx = xLow * LOW_SCALE;
    return Math.floor(groundYLocal(xPx) / LOW_SCALE);
  }

  // silueta
  gctx.beginPath();
  gctx.moveTo(0, lowH);
  gctx.lineTo(0, gyLow(0));
  for (let x = 1; x <= lowW; x++){
    gctx.lineTo(x, gyLow(x));
  }
  gctx.lineTo(lowW, lowH);
  gctx.closePath();

  // base
  gctx.fillStyle = G.deep;
  gctx.fill();

  // textura
	gctx.save();
	const oyLow = (Math.floor(floorOffsetY / LOW_SCALE)) | 0;

	gctx.save();
	gctx.setTransform(1,0,0,1,0,0); // â† evita acumulaciones raras en iOS
	gctx.clip();

	// scroll del pattern en X e Y (Y sigue el movimiento del suelo)
	gctx.translate(-oxLow, oyLow);

	gctx.fillStyle = groundPatternLow;

	// pintamos mÃ¡s grande para cubrir al mover en Y
	gctx.fillRect(oxLow, -lowH, lowW + oxLow + 2, lowH * 3);

	gctx.restore();


  // borde + sombra (mÃ¡s visible)
	const step = 1; // pon 1 si quieres mÃ¡ximo detalle //2
	const w = step;

	for (let x = 0; x <= lowW; x += step){
	  const y = gyLow(x);

	
	// sombra hacia el aire (arriba del borde) â€” MÃS CONTRASTE
	gctx.fillStyle = "rgba(60,120,220,0.35)"; // azul mÃ¡s luminoso
	if (y - 1 >= 0) gctx.fillRect(x, y - 1, w, 1);

	gctx.fillStyle = "rgba(40,90,170,0.25)";
	if (y - 2 >= 0) gctx.fillRect(x, y - 2, w, 1);

	  // borde claro
	  //gctx.fillStyle = "rgba(150,160,178,0.75)";
	  //gctx.fillRect(x, y, w, 1);
	}


  // upscale
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(groundLow, 0, 0, lowW, lowH, 0, 0, W, H);
  ctx.restore();
}



// --- Estrellas (2 capas, mÃ¡s aleatorias) ---
let starsFar = [];
let starsNear = [];

function initStars(){
  const rand = (a,b)=>a + Math.random()*(b-a);
  const mk = (n, sizeMin, sizeMax, hueChance)=>{
    const arr = [];
    for (let i=0;i<n;i++){
      // x en espacio "infinito" (se envuelve con worldX)
      const x = rand(0, W);
      const y = rand(0, H);
      const r = rand(sizeMin, sizeMax);
      const tw = rand(0, Math.PI*2);   // fase de twinkle
      const sp = rand(0.75, 1.35);     // variaciÃ³n por estrella
      const tint = (Math.random() < hueChance) ? 1 : 0;
      arr.push({x,y,r,tw,sp,tint});
    }
    return arr;
  };
  // far: mÃ¡s pequeÃ±as y mÃ¡s densas
  starsFar  = mk(220, 0.7, 1.8, 0.07);
  // near: menos densas, algunas mÃ¡s grandes
  starsNear = mk(120, 1.0, 2.7, 0.12);
}

  // FÃ­sica tipo "flappy en horizontal"
  const gravity = 1500;        // px/s^2  //2200
  const thrustV = 500;         // px/s (impulso arriba)  //660
  let worldSpeed = 360;        // px/s scroll

  // HalcÃ³n
  const ship = {
    x: 210,
    y: H * 0.48,
    vy: 0,
    rot: 0,         // rotaciÃ³n visual
    animT: 0,
    engineFlash: 0,
    r: 18           // radio aproximado para colisiÃ³n (mÃ¡s justo)
  };

  // Entidades
  const asteroids = [];
  const ties = [];
  const lasers = []; // disparos enemigos

  // Spawns
  let tAst = 0, nextAst = 0.8;
  let tTie = 0, nextTie = 2.2;
  let bigAstCooldown = 0; // evita meteoritos grandes seguidos (segundos)

  // Fondo
  let worldX = 0;

  //hitboxes
  let debugHitboxes = false;


  // Estado
  let running = false;
  let gameOver = false;
  let score = 0;
  let best = Number(localStorage.getItem("falcon_run_best") || 0);
  bestEl.textContent = best;

  const SPR = makeSprites();

  let lastT = performance.now();

  function rand(a,b){ return a + Math.random()*(b-a); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a, b, t){return a + (b - a) * t;
}


// RNG determinista (para sprites reproducibles)
	function mulberry32(seed){
	  let t = seed >>> 0;
	  return function(){
		t += 0x6D2B79F5;
		let x = Math.imul(t ^ (t >>> 15), 1 | t);
		x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
		return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
	  };
	}
  function reset(){
  
	resetLowCanvasesHard();  // ðŸ”¥ FIX iOS
	
	shields = 2;       // <--- AÃ±adir esta lÃ­nea
    invulTimer = 0;    // <--- AÃ±adir esta lÃ­nea
    shieldT = 0;
    shieldMsg = "";
	
    running = true;
    gameOver = false;
    score = 0;
    scoreEl.textContent = "0";
	
	phase3ScoreCarry = 0;

    worldSpeed = 360;

    ship.y = H * 0.48;
    ship.vy = 0;
    ship.rot = 0;
    ship.animT = 0;

    asteroids.length = 0;
    ties.length = 0;
    lasers.length = 0;

    tAst = 0; nextAst = rand(0.65, 0.95);
    tTie = 0; nextTie = rand(1.9, 2.6);

    worldX = 0;
    if (!starsFar.length) initStars();
	
    ensureGroundLow();

	 // âœ… limpiar FX
	  particles.length = 0;
	  debris.length = 0;
	  tieWrecks.length = 0;

	  shakeT = 0;
	  shakeAmp = 0;
	  flashT = 0;
	  // Fases
	  phase2Shown = false;
	  
	    // --- Reset fase 3 / tÃºnel ---
	  phase3 = false;
	  enteringPhase3 = false;
	  spawnAsteroids = true;
	  spawnTies = true;
	  floorOffsetY = 0;
	  ceilingOffsetY = 0;
	  tunnelT = 0;

	  
	  showPhase("Campo de asteroides", 2.6);
	  tAst = -phaseDur;   // espera hasta que termine el cartel de FASE 1

	  
	  if (audioEnabled){
		  musicStarted = true;
		  startMusic();
		} else {
		  musicStarted = false;
		  stopMusic();
		}

	  
  }

  function thrust(){
    if (!running) reset();
    if (gameOver && canRestart) { reset(); return; }
    ship.vy = -thrustV;
    ship.engineFlash = 15;
  }
  
  
	  // DEBUG: saltar rapido de fase con teclas "2" y "3"
  window.addEventListener("keydown", e=>{
    // Fase 2: desbloquea TIE Fighters
    if (e.key === "2" && !phase3 && !enteringPhase3){
      // Coloca el mundo justo despues del unlock y fuerza el aviso
      worldX = Math.max(worldX, TIE_UNLOCK_DIST + 10);
      // Reinicia temporizadores para que aparezcan pronto
      tTie = 0;
      nextTie = 0.08;
      if (!phase2Shown){
        phase2Shown = true;
        showPhase("Â¡Peligro! TIE Fighters", 2.2);
      }
    }

    // Fase 3: entrar en tunel/asteroide
    if (e.key === "3" && !phase3 && !enteringPhase3){
      beginPhase3();
    }
  });

window.addEventListener("keydown", (e) => {
  if (e.code === "Space") {
	e.preventDefault();
	
	unlockAudio().then(() => {
    if (!musicStarted && !gameOver) {
      startMusic();
      musicStarted = true;
    }
	});
	thrust();
   }

  if (e.code === "KeyR") {
	e.preventDefault();
	reset();
  }


  // Toggle hitboxes (H)
  if (e.code === "KeyH") {
    e.preventDefault();
    debugHitboxes = !debugHitboxes;
  }
}, { passive:false });

canvas.addEventListener("pointerdown", () => {
  unlockAudio().then(() => {
    if (!musicStarted && !gameOver) {
      startMusic();
      musicStarted = true;
    }
  });
  thrust();
});


  // --- Spawns ---
  function spawnAsteroid(){
    // Algunos meteoritos mucho mÃ¡s grandes (raros)
    let sizeType = 'normal';
    const roll = Math.random();
    if (roll < 0.03) sizeType = 'huge';
    else if (roll < 0.18) sizeType = 'big';

    // Evita encadenar grandes
    if (sizeType !== 'normal' && bigAstCooldown > 0) sizeType = 'normal';

    let r, speedMul, spinMul, hitMul;
    if (sizeType === 'huge'){
      r = rand(52, 70);
      speedMul = 0.72;
      spinMul = 0.55;
      hitMul = 0.86;
    } else if (sizeType === 'big'){
      r = rand(36, 48);
      speedMul = 0.84;
      spinMul = 0.75;
      hitMul = 0.88;
    } else {
      r = rand(16, 32);
      speedMul = 1.00;
      spinMul = 1.00;
      hitMul = 0.92;
    }

    if (sizeType !== 'normal') bigAstCooldown = 2.4;

    const y = rand(r+20, H - (r+20));

    // rotaciÃ³n y forma (elige sprite de 2 variantes)
    const variant = (Math.random() < 0.5) ? 0 : 1;
    const spin = rand(-2.2, 2.2) * spinMul;

    asteroids.push({
      x: W + 80,
      y,
      r,
      hitR: r * hitMul,
      sizeType,
      variant,
      a: rand(0, Math.PI*2),
      spin,
      vx: worldSpeed * speedMul * rand(0.95, 1.25)
    });
  }

  function spawnTIE(){
    const y = rand(70, H-70);
    const w = 66, h = 44;
    ties.push({
      x: W + 100,
      y,
      w, h,
      vx: worldSpeed * rand(0.90, 1.10),
      shootT: 0,
      nextShoot: rand(0.65, 1.25), // frecuencia de disparo
      anim: rand(0,100),
      passed: false
    });
  }

  // --- Colisiones ---
  function circleHit(ax, ay, ar, bx, by, br){
    const dx = ax - bx, dy = ay - by;
    return (dx*dx + dy*dy) <= (ar+br)*(ar+br);
  }

  function aabb(a,b){
    return a.x < b.x + b.w &&
           a.x + a.w > b.x &&
           a.y < b.y + b.h &&
           a.y + a.h > b.y;
  }

function spawnHitScreenFX(power = 1){
  // power ~ 0.7..1.3
  shakeT   = Math.max(shakeT, 0.10 * power);
  shakeAmp = Math.max(shakeAmp, 10 * power);
  flashT   = Math.max(flashT, 0.07 * power);
}

	
function spawnExplosion(x, y){
  // chispas (rÃ¡pidas)
  for (let i=0; i<26; i++){
    const a = rand(0, Math.PI*2);
    const sp = rand(220, 520);
    particles.push({
      x, y,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp,
      life: rand(0.25, 0.55),
      r: rand(1.2, 2.4),
      type: "spark"
    });
  }
  // humo (lento)
  for (let i=0; i<14; i++){
    const a = rand(0, Math.PI*2);
    const sp = rand(40, 140);
    particles.push({
      x: x + rand(-6, 6),
      y: y + rand(-6, 6),
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp,
      life: rand(0.55, 1.10),
      r: rand(4, 9),
      type: "smoke"
    });
  }

  // shake + flash
  shakeT = 0.18;
  shakeAmp = 10;
  flashT = 0.10;
}

function impactShake(){
  // pequeÃ±o, parecido al game over pero suave
  shakeT   = Math.max(shakeT || 0, 0.12);   // duraciÃ³n
  shakeAmp = Math.max(shakeAmp || 0, 10);   // intensidad
  flashT   = Math.max(flashT || 0, 0.05);   // flash corto (si lo usas)
}


function spawnMiniFX(x, y){
  // chispas + humo, sin shake/flash (para impactos menores)
  for (let i=0; i<10; i++){
    const a = rand(0, Math.PI*2);
    const sp = rand(140, 340);
    particles.push({ x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: rand(0.18, 0.38), r: rand(1.0, 2.0), type:"spark" });
  }
  for (let i=0; i<8; i++){
    const a = rand(0, Math.PI*2);
    const sp = rand(20, 90);
    particles.push({ x: x + rand(-6,6), y: y + rand(-6,6), vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: rand(0.35, 0.75), r: rand(3, 7), type:"smoke" });
  }
}

function makeRockPoly(){
  const n = (Math.random() * 3 + 4) | 0; // 4..6 lados
  const pts = [];
  for (let i = 0; i < n; i++){
    const a = (i / n) * Math.PI * 2 + rand(-0.35, 0.35);
    const rr = rand(0.55, 1.15);
    pts.push([Math.cos(a) * rr, Math.sin(a) * rr]);
  }
  return pts;
}

// --- FX simple: trozos de asteroide volando ---
function spawnAsteroidDebris(x, y, r){
  let n;
  if (r > 34)       n = rand(12, 18) | 0;
  else if (r > 26)  n = rand(9, 14)  | 0;
  else              n = rand(6, 10)  | 0;

  const sizeK = Math.min(1.35, r / 26); // ðŸ‘ˆ SOLO UNA VEZ

  for (let i = 0; i < n; i++){
    const a = rand(0, Math.PI * 2);
    const spike = (Math.random() < 0.10) ? rand(1.2, 1.6) : 1.0;
    const sp = rand(90, 210) * sizeK * spike;

    let rr = rand(2.5, 6.5) * sizeK;

    if (Math.random() < 0.12) rr *= rand(1.8, 2.4);
    rr = Math.min(rr, 14 * sizeK);

    debris.push({
      x: x + rand(-r*0.12, r*0.12),
      y: y + rand(-r*0.12, r*0.12),
      vx: Math.cos(a) * sp,
      vy: Math.sin(a) * sp,
      r: rr,
      rot: rand(0, Math.PI * 2),
      vr: rand(-8, 8),
      life: rand(0.55, 1.15),
      poly: makeRockPoly()
    });
  }

  if (r > 30 && Math.random() < 0.35){
    spawnMiniFX(x, y);
  }
}



// --- FX: TIE se rompe en 2 alas + cabina ---
function spawnTieWreck(x, y){
  // 2 alas (wing) + 1 cabina (cockpit)
  const pieces = [
    { kind: "wing",   side: -1, mark: -1, life: 1.6 },
    { kind: "wing",   side: +1, mark: +1, life: 1.6 },
    { kind: "cockpit", side: 0, mark:  0, life: 1.8 },
  ];

  for (const p of pieces){
  const ang = rand(0, Math.PI * 2);
  const sp  = (p.kind === "cockpit") ? rand(110, 190) : rand(150, 260);

  let vx = Math.cos(ang) * sp;
  let vy = Math.sin(ang) * sp;

  if (p.kind === "cockpit") vx -= 90;

  tieWrecks.push({
    kind: p.kind,
    x: x + (p.kind === "wing" ? p.side * 10 : 0),
    y: y + rand(-2, 2),
    vx, vy,
    rot: rand(-Math.PI, Math.PI),
    vr: (p.kind === "cockpit") ? rand(-3.5, 3.5) : rand(-6, 6),
    side: p.side,
    mark: p.mark,
    life: p.life
  });
}


  spawnMiniFX(x, y);
}



function updateDebrisAndWrecks(dt){
  // trozos de asteroide
  for (let i=debris.length-1; i>=0; i--){
    const d = debris[i];
    d.life -= dt;
    if (d.life <= 0){ debris.splice(i,1); continue; }
    d.vy += 320 * dt;              // gravedad suave
    d.vx *= Math.pow(0.45, dt);     // freno
    d.vy *= Math.pow(0.60, dt);
    d.x += d.vx * dt;
    d.y += d.vy * dt;
    d.rot += d.vr * dt;
    if (d.y > H + 80) { debris.splice(i,1); }
  }


  // restos de TIE: rebotan y giran por el espacio + estela simple
  for (let i=tieWrecks.length-1; i>=0; i--){
    const w = tieWrecks[i];
    w.life -= dt;
    if (w.life <= 0){ tieWrecks.splice(i,1); continue; }

    // movimiento "espacial" con leve fricciÃ³n
    w.vx *= Math.pow(0.92, dt);
    w.vy *= Math.pow(0.92, dt);
    w.x += w.vx * dt;
    w.y += w.vy * dt;
    w.rot += w.vr * dt;


    // estela: humo casi continuo + chispas ocasionales
    if (Math.random() < dt * 10){
      particles.push({
        x: w.x + rand(-3,3),
        y: w.y + rand(-3,3),
        vx: rand(-35,35),
        vy: rand(-35,35),
        life: rand(0.30, 0.65),
        r: rand(3, 7),
        type: "smoke"
      });
    }
    if (Math.random() < dt * 6){
      const a = rand(0, Math.PI*2);
      const sp = rand(120, 260);
      particles.push({
        x: w.x,
        y: w.y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        life: rand(0.15, 0.32),
        r: rand(1.0, 2.0),
        type: "spark"
      });
    }
  }
}



function hexPath(ctx, r, sy=1){
  // HexÃ¡gono vertical (sy permite estirar en Y)
  ctx.beginPath();
  for (let i=0;i<6;i++){
    const a = Math.PI/6 + i*(Math.PI/3); // 30Âº offset
    const x = Math.cos(a)*r;
    const y = Math.sin(a)*r*sy;
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
}

 
function drawTIECockpitChunk(ctx){
  const rOut = 6;
  const rIn  = 4;

  // exterior
  ctx.fillStyle = "#9ca3af";
  for (let yy = -rOut; yy <= rOut; yy++){
	const dx = Math.floor(Math.sqrt(rOut*rOut - yy*yy));
	ctx.fillRect(-dx, yy, dx*2 + 1, 1);
  }

  // interior desplazado a la izquierda (3D)
  const cxi = -2;
  ctx.fillStyle = "#6b7280";
  for (let yy = -rIn; yy <= rIn; yy++){
	const dx = Math.floor(Math.sqrt(rIn*rIn - yy*yy));
	ctx.fillRect(cxi - dx, yy, dx*2 + 1, 1);
  }

  // brillo
  ctx.fillStyle = "rgba(255,255,255,.12)";
  ctx.fillRect(cxi - 1, -1, 2, 2);

  // outline oscuro (para que se lea tipo sprite)
  ctx.strokeStyle = "#0b1020";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(0, 0, rOut + 0.5, 0, Math.PI*2);
  ctx.stroke();
}



// Helper: ala hexagonal EXACTAMENTE con el look del TIE (flat-top + borde + radios a 6 vÃ©rtices)
function drawTieWingPanelLikeOriginal(ctx, r, sy, mark){
  const fillCol  = "#3a3f46";
  const edgeCol  = "#7d828c";
  const notchCol = "rgba(0,0,0,0.22)";

  const ROT = Math.PI/6; // <-- pon aquÃ­ el MISMO que use tu hexPath/tie vivo

  ctx.fillStyle = fillCol;
  ctx.strokeStyle = edgeCol;
  ctx.lineWidth = 2;

  hexPath(ctx, r, sy); ctx.fill();
  hexPath(ctx, r, sy); ctx.stroke();

  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i=0; i<6; i++){
	const a = ROT + i*(Math.PI/3);
	ctx.moveTo(0,0);
	ctx.lineTo(Math.cos(a)*r*0.86, Math.sin(a)*r*0.86*sy);
  }
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,0.14)";
  ctx.fillRect(-0.5, -0.5, 1, 1);

  ctx.fillStyle = notchCol;
  const notchX = r * 0.72 * (mark || 1);
  ctx.fillRect((notchX)|0, (-r*0.55*sy)|0, 2, 1);
}

function drawDebrisAndWrecks(){

  // --- trozos de asteroide ---
  for (const d of debris){
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(d.rot);

    ctx.globalAlpha = Math.max(0, Math.min(1, d.life / 1.2));
    const s = d.r;

    // relleno roca
    ctx.fillStyle = "rgba(140,150,165,1)";

    if (d.poly){
      // fragmento poligonal
      ctx.beginPath();
      const p0 = d.poly[0];
      ctx.moveTo(p0[0] * s, p0[1] * s);
      for (let i = 1; i < d.poly.length; i++){
        const p = d.poly[i];
        ctx.lineTo(p[0] * s, p[1] * s);
      }
      ctx.closePath();
      ctx.fill();

      // borde sutil
      ctx.globalAlpha *= 0.55;
      ctx.strokeStyle = "rgba(210,220,235,1)";
      ctx.lineWidth = 1;
      ctx.stroke();

      // brillo pequeÃ±o
      ctx.globalAlpha *= 0.65;
      ctx.fillStyle = "rgba(210,220,235,1)";
      ctx.fillRect(-s*0.18, -s*0.18, s*0.22, s*0.22);

    } else {
      // fallback antiguo (cuadrado)
      ctx.fillRect(-s, -s, s*2, s*2);

      // puntito mÃ¡s claro para dar relieve
      ctx.globalAlpha *= 0.55;
      ctx.fillStyle = "rgba(210,220,235,1)";
      ctx.fillRect(-s*0.35, -s*0.35, s*0.55, s*0.55);
    }

    ctx.restore();
  }

  // --- restos de TIE (2 alas + cabina) ---
  for (const w of tieWrecks){
    ctx.save();
    ctx.translate(w.x, w.y);
    ctx.rotate(w.rot);

    const denom = (w.kind === "cockpit") ? 1.8 : 1.6;
    ctx.globalAlpha = Math.max(0, Math.min(1, w.life / denom));

    if (w.kind === "cockpit"){
      drawTIECockpitChunk(ctx);
    } else {
      drawTieWingPanelLikeOriginal(ctx, 10, 1.25, w.mark);
    }

    ctx.restore();
  }
}




function updateParticles(dt){
  for (let i=particles.length-1; i>=0; i--){
    const p = particles[i];
    p.life -= dt;
    if (p.life <= 0){ particles.splice(i,1); continue; }

    // fÃ­sica simple
    if (p.type === "spark"){
      p.vy += 900 * dt;          // gravedad a chispas
      p.vx *= Math.pow(0.20, dt); // freno
      p.vy *= Math.pow(0.25, dt);
    } else {
      p.vx *= Math.pow(0.45, dt);
      p.vy *= Math.pow(0.45, dt);
    }

    p.x += p.vx * dt;
    p.y += p.vy * dt;
  }

  if (shakeT > 0) shakeT = Math.max(0, shakeT - dt);
  if (flashT > 0) flashT = Math.max(0, flashT - dt);
}

function drawParticles(){
  ctx.save();
  ctx.globalCompositeOperation = "lighter";

  for (const p of particles){
    const t = Math.max(0, Math.min(1, p.life)); // solo para modulaciÃ³n simple
    if (p.type === "spark"){
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(255,200,120,1)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "rgba(255,80,60,1)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r*1.8, 0, Math.PI*2);
      ctx.fill();
    } else {
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "rgba(80,90,110,1)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  ctx.restore();

  // flash blanco breve
  if (flashT > 0){
    ctx.save();
    ctx.globalAlpha = (flashT / 0.10) * 0.35;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }
}


function unlockAudio(){
  if (audioUnlocked) return Promise.resolve();
  if (audioUnlockPromise) return audioUnlockPromise;

  audioUnlocked = true;

  audioUnlockPromise = music.play().then(async () => {
    // Pausar si no toca mÃºsica
    if (!musicStarted || !audioEnabled){
      music.pause();
      music.currentTime = 0;
    }

    // Si abrimos desde file://, evitamos intentos de carga que disparan CORS
    const isFile = (location.protocol === "file:");

    // ðŸ”¥ Precalentar FX HTMLAudio (solo si NO es file://)
    if (!isFile){
      laserPool.forEach(a => {
        try { a.load(); } catch(e){}
      });
      try { sfxCrash.load(); } catch(e){}
    }

    // WebAudio FX (blindado)
    try{
      const ok = await initLaserWebAudio(); // devuelve true/false si aplicaste mi versiÃ³n
      if (ok && laserCtx && laserCtx.state === "suspended"){
        laserCtx.resume().catch(()=>{});
      }
    } catch(e){
      // no hacemos nada: sin audio pero el juego sigue
    }

  }).catch(() => {});

  return audioUnlockPromise;
}





  function crash(){
    if (gameOver) return;
	
	playCrash();
	stopMusic();
	
	spawnExplosion(ship.x, ship.y);
    gameOver = true;
	phaseT = 0;
	phaseMsg = "";
	shieldT = 0;
	shieldMsg = "";
    const s = Math.floor(score) *10;
    if (s > best){
      best = s;
      localStorage.setItem("falcon_run_best", String(best));
      bestEl.textContent = String(best);
    }
	canRestart = false;
	restartTimer = 1.2;   // segundos que debe verse la explosiÃ³n

  }
  
  // Aviso pixel al perder un escudo
  function showShieldLoss(){
    // shields ya viene decrementado en las colisiones
    shieldMsg = (shields > 0) ? "ESCUDOS 50%" : "ESCUDOS 0%";
    shieldDur = 1.5; // segundos
    shieldT = shieldDur;
  }


  
  function beginPhase3(){
  enteringPhase3 = true;
  phase3 = false;
  tunnelT = 0;

  phase3StartX = worldX; // âœ… para medir progreso de estrechamiento
  
  showPhase("ENTRANDO EN ASTEROIDE", 2.6);

  // dejan de generarse (pero NO borramos arrays)
  spawnAsteroids = false;
  spawnTies = false;

  // --- inicio de transiciÃ³n ---
  floorStartOffsetY = 0;          // suelo parte de su posiciÃ³n normal
  ceilingStartOffsetY = -H - 80;  // techo totalmente fuera (arriba). Ajusta -80 si quieres

  floorOffsetY = floorStartOffsetY;
  ceilingOffsetY = ceilingStartOffsetY;
}

function updateTunnelHold(dt){
  if (!phase3) return;

  // targets actuales segÃºn gap dinÃ¡mico
  const targetFloor = tunnelCenterY() + tunnelHalfGap();
  const targetCeil  = tunnelCenterY() - tunnelHalfGap();

  // offsets necesarios AHORA (en la X de la nave)
  const endFloorOffset = targetFloor - groundY(ship.x);
  const endCeilOffset  = targetCeil  - ceilingY(ship.x);

  // seguimiento suave para que no â€œsalteâ€
  const follow = 1 - Math.exp(-dt * 6.0); // 6 = rapidez de ajuste (sube/baja)
  floorOffsetY   = lerp(floorOffsetY,   endFloorOffset, follow);
  ceilingOffsetY = lerp(ceilingOffsetY, endCeilOffset,  follow);
}


function updateTunnelTransition(dt){
  if (!enteringPhase3) return;

  tunnelT = Math.min(1, tunnelT + dt / tunnelDuration);
  const k = easeInOut(tunnelT);

  // objetivos (en la X de la nave)
  const targetFloor = tunnelCenterY() + tunnelHalfGap();
  const targetCeil  = tunnelCenterY() - tunnelHalfGap();

  const curFloor = groundY(ship.x);
  const curCeil  = ceilingY(ship.x);

  // offsets finales necesarios para colocar suelo/techo en su objetivo
  const endFloorOffset = (targetFloor - curFloor);
  const endCeilOffset  = (targetCeil  - curCeil);

  // InterpolaciÃ³n: suelo desde 0 â†’ final; techo desde fuera â†’ final
  floorOffsetY   = lerp(floorStartOffsetY,   endFloorOffset, k);
  ceilingOffsetY = lerp(ceilingStartOffsetY, endCeilOffset,  k);

  if (tunnelT >= 1){
    enteringPhase3 = false;
    phase3 = true;
  }
}


function maybeEnterPhase3(){
  if (!phase3 && !enteringPhase3 && worldX >= PHASE3_UNLOCK_DIST){
    beginPhase3();
  }
}


  function update(dt){
  
	//updateParticles(dt);
	//updateDebrisAndWrecks(dt);
	// timer avisos de fase
	if (phaseT > 0) phaseT = Math.max(0, phaseT - dt);
	// timer aviso escudo
	if (shieldT > 0) shieldT = Math.max(0, shieldT - dt);
    if (!running) return;

    // Dificultad suave
    worldSpeed = 360 + Math.min(420, score * 7);
    const astRate = (score > 18) ? 0.90 : 1.0; // un pelÃ­n mÃ¡s denso con score
    const tieRate = (score > 25) ? 0.92 : 1.0;

    worldX += worldSpeed * dt;
		// puede activar fase 3 segÃºn distancia
		
	// Score por distancia en fase 3 (aunque no haya enemigos)
	if (phase3 || enteringPhase3){
	  // puntos por pixel recorrido
	  const ptsPerPx = PHASE3_SCORE_PER_1000PX / 1000;

	  // acumulamos con el avance real del mundo este frame
	  phase3ScoreCarry += worldSpeed * dt * ptsPerPx;

	  // suma solo la parte entera (mantiene score â€œlimpioâ€)
	  const add = phase3ScoreCarry | 0;
	  if (add > 0){
		score += add;
		phase3ScoreCarry -= add;
	  }
	}
	
	maybeEnterPhase3();

	// si estamos entrando, mover offsets de suelo/techo
	updateTunnelTransition(dt);
	
	updateTunnelHold(dt);

    bigAstCooldown = Math.max(0, bigAstCooldown - dt);

    // FÃ­sica nave
    ship.vy += gravity * dt;
    ship.y  += ship.vy * dt;
    // --- ROTACIÃ“N: solo hacia arriba y vuelta suave a horizontal ---
	const maxUp = 0.45;                 // rad (~26Â°) mÃ¡ximo hacia arriba
	const targetRot = (ship.vy < -40) ? -maxUp : 0; // subiendo -> inclina arriba, si no -> 0

	// velocidad de giro distinta segÃºn direcciÃ³n (subida lenta, retorno mÃ¡s rÃ¡pido)
	const upRate = 3.0;    // mÃ¡s bajo = mÃ¡s lento al subir
	const downRate = 8.0;  // mÃ¡s alto = vuelve mÃ¡s rÃ¡pido a horizontal

	const rate = (targetRot < ship.rot) ? upRate : downRate; // si vamos hacia arriba, usa upRate
	const smooth = 1 - Math.exp(-rate * dt);

	ship.rot += (targetRot - ship.rot) * smooth;

	// Seguridad: nunca nose-down
	if (ship.rot > 0) ship.rot = 0;


    // techo/suelo
	if (enteringPhase3 || phase3){
	  // colisiÃ³n contra tÃºnel (techo dinÃ¡mico + suelo dinÃ¡mico)
	  if (ship.y - ship.r < ceilingYEff(ship.x)){
		crash(); return;
	  }
	  if (ship.y + ship.r > floorYEff(ship.x)){
		crash(); return;
	  }
	} else {
	  // modo normal
	  if (ship.y - ship.r < 0){
		crash(); return;
	  }
	  if (ship.y + ship.r > groundY(ship.x)){
		crash(); return;
	  }
	}



    // Spawns (asteroides)
	if (spawnAsteroids){
	  tAst += dt;
	  if (tAst >= nextAst){
		tAst = 0;
		nextAst = rand(0.55, 0.95) * (worldSpeed > 650 ? 0.92 : 1) * astRate;
		spawnAsteroid();
	  }
	}


    
	// Aviso de FASE 2 al desbloquear TIE (sin pausar)
	if (!phase2Shown && worldX >= TIE_UNLOCK_DIST){
	  phase2Shown = true;
	  showPhase("Â¡Peligro! TIE Fighters", 2.8);
	}

	// Solo aparecen TIE cuando has avanzado suficiente
	if (worldX >= TIE_UNLOCK_DIST){
	  if (spawnTies){
		tTie += dt;
		if (tTie >= nextTie){
		  tTie = 0;
		  nextTie = rand(1.9, 2.6) * tieRate;
		  spawnTIE();
		}
	  }
	} else {
	  // evita â€œburstâ€ al desbloquear
	  tTie = 0;
	}


    // Mover asteroides
    for (let i=asteroids.length-1;i>=0;i--){
      const a = asteroids[i];

      // Si ha sido destruido (choque con escudo), lo quitamos con FX
      if (a.dead){
        spawnAsteroidDebris(a.x, a.y, a.r);
        asteroids.splice(i,1);
        continue;
      }

      a.x -= a.vx * dt;
      a.a += a.spin * dt;

      // score por "pasar"
      if (a.x + a.r < ship.x - 40 && !a.passed){
        a.passed = true;
        score += 0.25;
      }

      if (a.x + a.r < -120) asteroids.splice(i,1);
    }

    // Mover TIE + disparar
    for (let i=ties.length-1;i>=0;i--){
      const t = ties[i];
      // Si ha sido destruido (choque con escudo), lo quitamos con FX
      if (t.dead){
        spawnTieWreck(t.x, t.y);
        ties.splice(i,1);
        continue;
      }

      t.x -= t.vx * dt;

      // score por esquivar TIE (cuando pasa)
      if (!t.passed && t.x + t.w < ship.x - 10){
        t.passed = true;
        score += 1;
        scoreEl.textContent = String(Math.floor(score)*10);
      }

      // disparos
      t.shootT += dt;
      if (!gameOver && t.shootT >= t.nextShoot && t.x < W - 60){
        t.shootT = 0;
        t.nextShoot = rand(0.60, 1.15) * (score > 20 ? 0.90 : 1);

        // lÃ¡ser hacia la izquierda (ligero spread vertical hacia el HalcÃ³n)
        const vx = -(worldSpeed * 1.85);  // MÃS rÃ¡pido
		const vy = 0;                     // SIN diagonal (recto)

		// dispara desde el â€œfrenteâ€ del TIE (lado izquierdo del sprite)
		lasers.push({
		  x: t.x,
		  y: t.y,
		  vx, vy,
		  w: 22,   // un pelÃ­n mÃ¡s largo
		  h: 4,
		  life: 2.0
		});
		
		playLaser();

      }

      if (t.x + t.w < -180) ties.splice(i,1);
    }

    // Mover lÃ¡seres
    for (let i=lasers.length-1;i>=0;i--){
      const l = lasers[i];
      l.x += l.vx * dt;
      l.y += l.vy * dt;
      l.life -= dt;

      // colisiÃ³n vs nave (solo aquÃ­, para no mover 2 veces)
      const shipBox = { x: ship.x - 20, y: ship.y - 14, w: 40, h: 28 };
      const laserBox = { x: l.x, y: l.y - (l.h / 2), w: l.w, h: l.h };

      if (aabb(shipBox, laserBox)) {
        if (invulTimer <= 0) {
          if (shields > 0) {
            shields--;
            showShieldLoss();
            invulTimer = 60; // ~1s (frames)
            // pequeÃ±o FX (sin shake)
            spawnMiniFX(ship.x, ship.y);
            // el lÃ¡ser se consume al impactar
            lasers.splice(i,1);
            continue;
          } else {
            crash();
            return;
          }
        } else {
          // invulnerable: consume el lÃ¡ser para evitar "metralleta" visual
          lasers.splice(i,1);
          continue;
        }
      }

      // fuera
      if (l.life <= 0 || l.x < -200 || l.y < -60 || l.y > H+60) {
        lasers.splice(i,1);
        continue;
      }
	 }


    // --- 2. ColisiÃ³n NAVE vs ASTEROIDES ---
    for (const a of asteroids) {
      if (circleHit(ship.x, ship.y, ship.r, a.x, a.y, (a.hitR ?? (a.r * 0.92)))) {
        if (invulTimer <= 0) {
          if (shields > 0) {
            shields--;
            showShieldLoss();
			spawnHitScreenFX(shields === 1 ? 1.15 : 1.0);
			spawnMiniFX(ship.x, ship.y); // opcional, queda muy bien para â€œimpactoâ€
			impactShake();
			
            invulTimer = 60;
            if (window.sfxCrash) sfxCrash.play();
            a.dead = true; 
          } else {
            crash(); 
            return;
          }
        }
      }
    }

    // --- 3. ColisiÃ³n NAVE vs TIE ---
    const shipHit = { x: ship.x - 18, y: ship.y - 12, w: 36, h: 24 };
    for (const t of ties) {
      const tieHit = { x: t.x + 14, y: t.y - (t.h / 2) + 10, w: t.w - 28, h: t.h - 20 };
      if (aabb(shipHit, tieHit)) {
        if (invulTimer <= 0) {
          if (shields > 0) {
            shields--;
            showShieldLoss();
			spawnHitScreenFX(shields === 1 ? 1.15 : 1.0);
			spawnMiniFX(ship.x, ship.y); // opcional, queda muy bien para â€œimpactoâ€
			impactShake();
            invulTimer = 60;
            if (window.sfxCrash) sfxCrash.play();
            t.dead = true; 
          } else {
            crash(); 
            return;
          }
        }
      }
    }

    // Importante: bajar el contador de invulnerabilidad fuera de los bucles
    if (invulTimer > 0) invulTimer--;

    // actualizar score mostrado aunque sumemos fracciones por asteroides
    scoreEl.textContent = String(Math.floor(score)*10);
	
	// Motor: flash instantÃ¡neo (solo 1 frame)
	// Motor: flash 1-frame visible (update va antes que draw)
	if (ship.engineFlash > 0) ship.engineFlash--;
	

  }

  // --- Dibujo ---
  
 function drawBgPlanet(){
  if (!bgPlanetReady) return;

  const targetW = W * 0.08; // un poco mÃ¡s grande si quieres que se note â€œlejosâ€
  const aspect =
    (bgPlanetImg.naturalHeight || bgPlanetImg.height || 1) /
    (bgPlanetImg.naturalWidth  || bgPlanetImg.width  || 1);

  const w = targetW;
  const h = targetW * aspect;

  // Centro-derecha, arriba
  const x = (W - w) * 0.80;
  const y = H * 0.08;

  ctx.save();

  // Planeta base (sin blur)
  ctx.globalAlpha = 0.70;
  ctx.globalCompositeOperation = 'source-over';
  ctx.drawImage(bgPlanetImg, x, y, w, h);

  // IntegraciÃ³n: oscurecer con el color del espacio
  ctx.globalCompositeOperation = 'multiply';
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = '#050611';
  ctx.fillRect(x, y, w, h);

  // ViÃ±eta: bordes mÃ¡s oscuros para â€œmeterloâ€ en el fondo
  ctx.globalCompositeOperation = 'source-over';
  const g = ctx.createRadialGradient(x + w*0.5, y + h*0.5, w*0.10, x + w*0.5, y + h*0.5, w*0.70);
  g.addColorStop(0, 'rgba(0,0,0,0)');
  g.addColorStop(1, 'rgba(0,0,0,0.28)');
  ctx.globalAlpha = 1;
  ctx.fillStyle = g;
  ctx.fillRect(x, y, w, h);

  // Niebla frÃ­a por delante (opcional)
  ctx.globalAlpha = 0.2;
  ctx.fillStyle = 'rgba(20, 30, 70, 0.22)';
  ctx.fillRect(x, y, w, h);

  ctx.restore();
}


  function drawHitboxes(){
    if (!debugHitboxes) return;

    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.globalAlpha = 0.95;
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255, 225, 0, 0.95)"; // amarillo
    ctx.setLineDash([]);

    // HalcÃ³n: cÃ­rculo principal
    ctx.beginPath();
    ctx.arc(ship.x, ship.y, ship.r, 0, Math.PI*2);
    ctx.stroke();

    // HalcÃ³n: AABB vs lÃ¡ser
    const shipBox = { x: ship.x-20, y: ship.y-14, w: 40, h: 28 };
    ctx.strokeRect(shipBox.x, shipBox.y, shipBox.w, shipBox.h);
	

    // HalcÃ³n: AABB vs TIE
    const shipHit = { x: ship.x-18, y: ship.y-12, w: 36, h: 24 };
    ctx.strokeRect(shipHit.x, shipHit.y, shipHit.w, shipHit.h);

    // Asteroides: cÃ­rculo de colisiÃ³n
    for (const a of asteroids){
      const r = (a.hitR ?? (a.r*0.92));
      ctx.beginPath();
      ctx.arc(a.x, a.y, r, 0, Math.PI*2);
      ctx.stroke();
    }

    // TIE: hitbox ajustada (igual que colisiÃ³n)
    for (const t of ties){
      const tieHit = { x: t.x+14, y: t.y-(t.h/2)+10, w: t.w-28, h: t.h-20 };
      ctx.strokeRect(tieHit.x, tieHit.y, tieHit.w, tieHit.h);
    }

    // LÃ¡seres: AABB
    for (const l of lasers){
      const laserBox = { x: l.x, y: l.y - (l.h/2), w: l.w, h: l.h };
      ctx.strokeRect(laserBox.x, laserBox.y, laserBox.w, laserBox.h);
    }

    ctx.restore();
  }
  
  function drawGroundHitbox(){
	  if (!debugHitboxes) return;

	  ctx.save();
	  ctx.strokeStyle = "rgba(255,255,0,0.9)";
	  ctx.lineWidth = 1;

	  // Suelo (normal o tÃºnel)
	  ctx.beginPath();
	  for (let x = 0; x <= W; x++){
		const y = (enteringPhase3 || phase3) ? floorYEff(x) : groundY(x);
		if (x === 0) ctx.moveTo(x, y|0);
		else ctx.lineTo(x, y|0);
	  }
	  ctx.stroke();

	  // Techo del tÃºnel
	  if (enteringPhase3 || phase3){
		ctx.strokeStyle = "rgba(0,255,255,0.85)";
		ctx.beginPath();
		for (let x = 0; x <= W; x++){
		  const y = ceilingYEff(x);
		  if (x === 0) ctx.moveTo(x, y|0);
		  else ctx.lineTo(x, y|0);
		}
		ctx.stroke();
	  }

	  ctx.restore();
 }


function draw(){
    ctx.clearRect(0,0,W,H);

	// SHAKE: mueve la â€œcÃ¡maraâ€ un instante tras crash
	  ctx.save();
	  if (shakeT > 0){
		const k = shakeT / 0.18;              // 1..0
		const sx = ((Math.random()*2-1) * shakeAmp * k) | 0;
		const sy = ((Math.random()*2-1) * shakeAmp * k) | 0;
		ctx.translate(sx, sy);
	  }
    // fondo espacio
    ctx.fillStyle = "#040510";
    ctx.fillRect(0,0,W,H);

    
    
	drawStarsLayer(starsFar,  0.08, 0.60);  // mÃ¡s lenta y algo mÃ¡s visible
	drawBgPlanet(); // Planeta fijo (no se mueve con worldX)
	drawStarsLayer(starsNear, 0.10, 0.85);
	if (enteringPhase3 || phase3){
	  drawCeilingSurface();
	}
	drawPlanetSurface();



    // asteroides
    for (const a of asteroids){
      const spr = (a.variant===0) ? SPR.asteroidA : SPR.asteroidB;
      const size = (a.r*2)|0;
      ctx.save();
      ctx.translate(a.x|0, a.y|0);
      ctx.rotate(a.a);
      ctx.drawImage(spr, (-size/2)|0, (-size/2)|0, size, size);
      ctx.restore();
    }

    // TIE
    for (const t of ties){
      const frame = Math.floor((t.anim += 0.18) % 2);
      const spr = SPR.tie[frame];
      const S = 0.75; // TIE mÃ¡s pequeÃ±o o grande, prueba 0.90â€“0.95
		ctx.drawImage(
		  spr,
		  (t.x + t.w*(1-S)/2) | 0,
		  (t.y - (t.h*S)/2) | 0,
		  (t.w * S) | 0,
		  (t.h * S) | 0
		);
    }

   for (const l of lasers){

	  // ðŸŽ² radio variable del glow (flicker sutil)
	  const r = 3 + Math.random()*2;

	  // === GLOW redondeado ===
	  ctx.save();
	  ctx.globalAlpha = 0.35;
	  ctx.fillStyle = getCSS("--laser");

	  ctx.beginPath();
	  ctx.roundRect(
		(l.x|0) - 4,
		((l.y - 1)|0) - 4,
		(l.w + 8)|0,
		10,
		r        // ðŸ‘ˆ aquÃ­ usas el radio variable
	  );
	  ctx.fill();
	  ctx.restore();

	  // === Cuerpo fino ===
	  ctx.fillStyle = getCSS("--laser");
	  ctx.fillRect(l.x|0, (l.y - 1)|0, l.w|0, 2);

	  // === NÃºcleo blanco ===
	  ctx.fillStyle = "rgba(255,255,255,.55)";
	  ctx.fillRect((l.x + 2)|0, (l.y)|0, (l.w - 6)|0, 1);
	}

    // HalcÃ³n
    drawFalcon();


    // Debug hitboxes (H)
    drawHitboxes();
	drawGroundHitbox(); 

    // UI
    if (!running){
		centerPixelText("", 3, -12, "#E9EEF7");
		centerPixelText("CLICK O ESPACIO PARA EMPEZAR", 2, 22, "rgba(154,167,189,.95)");

    }
    if (gameOver){
	  const s = String(Math.floor(score)*10);
	  const cx = (W / 2) | 0;

	  // tamaÃ±os
	  const scTitle = 5;
	  const scScore = 3;
	  const scHint  = 2;

	  // altura de lÃ­nea segura para tu fuente pixel
	  const lineH = (scale) => (9 * scale); // 8 = alto seguro (7px + margen)

	  // posiciÃ³n base
	  let y = (H * 0.34) | 0;

	  ctx.save();
	  ctx.globalAlpha = 0.95;
	  drawPixelText(ctx, "GAME OVER", cx, y, scTitle, "#E9EEF7", "center");
	  ctx.restore();

	  y += lineH(scTitle) + 8; // separaciÃ³n extra

	  ctx.save();
	  ctx.globalAlpha = 0.8;
	  drawPixelText(ctx, "SCORE: " + s, cx, y, scScore, "#E9EEF7", "center");
	  ctx.restore();

	  y += lineH(scScore) + 8;

	  ctx.save();
	  ctx.globalAlpha = canRestart ? 0.7 : 0.45;
	  drawPixelText(ctx, "", cx, y, scHint, "#E9EEF7", "center");  //"CLICK / ESPACIO /R  PARA REINICIAR"
	  ctx.restore();
	}




   // score pixel pequeÃ±o (arriba a la izquierda, translÃºcido)
	if (running && !gameOver){
	  const label = "SCORE:";
	  const value = String(Math.floor(score)*10);

	  const scale = 2;      // tamaÃ±o pixel
	  const x = 14;         // margen izquierdo
	  const y = 12;         // margen superior

	  // ancho aproximado del texto "SCORE:" en pÃ­xeles
	  // (5 letras + ':' = 6 caracteres)
	  const charW = 6 * scale;   // ancho por carÃ¡cter (tu fuente pixel)
	  const gap = 6;             // separaciÃ³n entre texto y nÃºmero

	  ctx.save();
	  ctx.globalAlpha = 0.35;

	  // "SCORE:"
	  drawPixelText(ctx, label, x, y, scale, "#E9EEF7", "left");

	  // nÃºmero, desplazado a la derecha
	  const xValue = x + label.length * charW + gap;
	  drawPixelText(ctx, value, xValue, y, scale, "#E9EEF7", "left");

	  ctx.restore();
	}


	
	drawParticles();
	drawDebrisAndWrecks();

	// Aviso de fase (aparece y se desvanece)
	if (!gameOver && phaseT > 0 && phaseMsg){
		// decae con el tiempo real
		// (phaseT se reduce en loop, por si el frame rate cambia)
		const tLeft = phaseT;
		const t = phaseDur - tLeft;
		const fade = 0.35;
		let a = 1;
		if (t < fade) a = t / fade;
		else if (tLeft < fade) a = tLeft / fade;
		a = Math.max(0, Math.min(1, a));
		ctx.save();
		ctx.globalAlpha = 0.92 * a;
		ctx.fillStyle = "rgba(0,0,0,0.22)";
		//ctx.fillRect(0, (H/2 - 34)|0, W, 68);
		centerPixelText(phaseMsg, 3, 0, "#E9EEF7");
		ctx.restore();
	}

	// Aviso de escudo (aparece, parpadea y se desvanece)
	if (!gameOver && shieldT > 0 && shieldMsg){
		const tLeft = shieldT;
		const t = shieldDur - tLeft;          // tiempo transcurrido desde que empezÃ³ el aviso
		const fade = 0.20;
		let a = 1;
		if (t < fade) a = t / fade;
		else if (tLeft < fade) a = tLeft / fade;
		a = Math.max(0, Math.min(1, a));

		// Parpadeo: 8 Hz (ajusta si quieres mÃ¡s/menos rÃ¡pido)
		const blinkOn = (Math.floor(t * 8) % 2) === 0;
		if (blinkOn){
			ctx.save();
			ctx.globalAlpha = 0.95 * a;
			centerPixelText(shieldMsg, 2.6, -56, "#FFD166");
			ctx.restore();
		}
	}

	// âœ… MUY IMPORTANTE: volver al estado previo al shake
	ctx.restore();


  }

function drawFalcon(){
  ctx.save();
  ctx.translate((ship.x|0), (ship.y|0));
  ctx.rotate(ship.rot);

  // --- 1. ESCUDO (DEBAJO DE TODO - DOBLE CÃRCULO GLOW) ---
  if (shields > 0) {
    ctx.save();
    if (invulTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
      ctx.globalAlpha = 0.3;
    }
    
    ctx.globalCompositeOperation = "lighter";
    const xPos = -12; // Desplazado a la izquierda
    
    // COLORES SEGÃšN NIVEL DE ESCUDO
    // Nivel 2: Cian y Blanco / Nivel 1: Naranja y Dorado
    const colorOut = (shields === 2) ? "rgba(0, 212, 255, 0.15)" : "rgba(255, 120, 0, 0.15)";
    const colorIn  = (shields === 2) ? "rgba(224, 251, 255, 0.3)"  : "rgba(255, 230, 150, 0.3)";
    const glowColor = (shields === 2) ? "#00d4ff" : "#ffbd45";

    // CÃRCULO EXTERIOR (MÃ¡s grande y difuso)
    ctx.shadowBlur = 45;
    ctx.shadowColor = glowColor;
    ctx.beginPath();
    ctx.arc(xPos, 0, 42, 0, Math.PI * 2);
    ctx.fillStyle = colorOut;
    ctx.fill();

    // CÃRCULO INTERIOR (MÃ¡s pequeÃ±o y brillante)
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(xPos, 0, 36, 0, Math.PI * 2);
    ctx.fillStyle = colorIn;
    ctx.fill();

    ctx.restore();
  }

  // --- 2. MOTOR (ENCIMA DEL ESCUDO, DEBAJO DE LA NAVE) ---
  const pulse = ship.engineFlash ? 1.0 : 0.0; 
  if (pulse > 0) { 
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const gx = -14, gy = 0, r = 31; 
    ctx.shadowColor = "#00d4ff";
    ctx.shadowBlur = 55; 
    const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, r + 20);
    grad.addColorStop(0.00, `rgba(255, 255, 255, 0.9)`);
    grad.addColorStop(0.20, `rgba(130, 240, 255, 0.9)`);
    grad.addColorStop(0.50, `rgba(0, 100, 255, 0.4)`);
    grad.addColorStop(1.00, `rgba(0, 50, 255, 0)`);
    ctx.strokeStyle = grad;
    ctx.lineWidth = 15; 
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.arc(gx, gy, r, Math.PI * 0.8, Math.PI * 1.2);
    ctx.stroke();
    ctx.lineWidth = 6;
    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
    ctx.stroke();
    ctx.restore();
  }

  // --- 3. DIBUJO DE LA NAVE (ENCIMA DE TODO) ---
  if (falconReady){
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    const scale = 1.15;
    const w = falconImg.width  * scale;
    const h = falconImg.height * scale;
    if (shields <= 0 && invulTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
       ctx.globalAlpha = 0.4;
    }
    ctx.drawImage(falconImg, (-w/2)|0, (-h/2)|0, w|0, h|0);
    ctx.restore();
  }

  ctx.restore();
}



  // --- Fondo ---
  function drawStarsLayer(stars, parallax, baseAlpha){
  const off = (worldX * parallax) % W;
  const t = performance.now() * 0.001;
  ctx.save();
  for (let i=0;i<stars.length;i++){
    const s = stars[i];
    const x = ((s.x * s.sp + (W - off)) % W);
    const y = s.y;
    const tw = 0.65 + 0.35 * Math.sin(t*1.8 + s.tw);
    const a  = baseAlpha * tw;

    // color: mayorÃ­a blanco, algunas azuladas
    if (s.tint){
      ctx.fillStyle = `rgba(125,211,252,${0.80*a})`;
    }else{
      ctx.fillStyle = `rgba(255,255,255,${0.85*a})`;
    }
    const r = s.r;
    ctx.fillRect(x|0, y|0, r|0 || 1, r|0 || 1);
  }
  ctx.restore();
}


  function drawSpeedStreaks(){
    ctx.save();
    ctx.globalAlpha = 0.14;
    ctx.fillStyle = "rgba(233,238,247,1)";
    const off = (worldX * 0.7) % 180;
    for (let i=0;i<22;i++){
      const x = (W - off - i*90) | 0;
      const y = (26 + (i*21) % (H-52)) | 0;
      ctx.fillRect(x, y, 26, 1);
    }
    ctx.restore();
  }

  function centerText(text, size, color, yOffset){
    ctx.save();
    ctx.fillStyle = color;
    ctx.font = `700 ${size}px ui-sans-serif,system-ui`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, W/2, H/2 + yOffset);
    ctx.restore();
  }

  function getCSS(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || "#ff4d4d";
  }

  // --- Sprites pixel art (mejor falcon + TIE + asteroides) ---

function makeSprites(){
  // helper: canvas pequeÃ±o para sprites
  const mk = (w,h) => {
	  const c = document.createElement("canvas");
	  c.width = w; c.height = h;
	  const g = c.getContext("2d", { willReadFrequently: true });
	  g.imageSmoothingEnabled = false;
	  return [c,g];
	};


  function px(g,x,y,w,h,color){ g.fillStyle=color; g.fillRect(x|0,y|0,w|0,h|0); }

  function hexToRgb(hex){
    if (!hex || !hex.startsWith("#")) return {r:0,g:0,b:0};
    const n = parseInt(hex.slice(1), 16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }

  function outline(g, color){
    const img = g.getImageData(0,0,g.canvas.width,g.canvas.height);
    const d = img.data;
    const w = img.width, h = img.height;
    const out = g.getImageData(0,0,w,h);
    const od = out.data;

    const rgb = hexToRgb(color);

    function a(ix,iy){
      if (ix<0||iy<0||ix>=w||iy>=h) return 0;
      return d[(iy*w+ix)*4+3];
    }

    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        if (a(x,y)===0) continue;
        const edge = (a(x-1,y)===0 || a(x+1,y)===0 || a(x,y-1)===0 || a(x,y+1)===0);
        if (edge){
          const i=(y*w+x)*4;
          od[i]=rgb.r; od[i+1]=rgb.g; od[i+2]=rgb.b; od[i+3]=220;
        }
      }
    }
    g.putImageData(out,0,0);
    g.putImageData(img,0,0);
  }

  // Motor glow
  const engine = [];
  for (let f=0; f<2; f++){
    const [c,g] = mk(18,12);
    g.clearRect(0,0,18,12);
    px(g, 2, 3, 12, 6, "rgba(125,211,252,.85)");
    px(g, 3, 4, 10, 4, f ? "rgba(255,255,255,.35)" : "rgba(255,255,255,.18)");
    outline(g, "#0b1020");
    engine.push(c);
  }


// TIE (2 frames) â€” alas = mismo hex que los trozos
const tie = [];

// 1) Helper: hex estilo "trozo" (MISMA receta visual que tus wrecks)
function tieHexLikeWreck(g, cx, cy, r){
  g.save();
  g.translate(cx, cy);
  const ROT = Math.PI / 3;
  const SY  = 1.25;          // â† FACTOR VERTICAL (1.1â€“1.25 ideal)
  
  // Hex (flat-top: lado arriba)  
  g.beginPath();
  for (let i = 0; i < 6; i++){    
	const a = ROT + i * (Math.PI / 3);
    const x = Math.cos(a) * r;
	const y = Math.sin(a) * r * SY;
    if (i === 0) g.moveTo(x, y);
    else g.lineTo(x, y);
  }
  g.closePath();

  // Relleno (ala oscura)
  g.fillStyle = "#3a3f46";
  g.fill();

  // Borde
  g.strokeStyle = "#7d828c";
  g.lineWidth = 2;
  g.stroke();

  // Radios interiores: mismo color que el borde (centro -> 6 vÃ©rtices)
  g.strokeStyle = "#7d828c";
  g.lineWidth = 1;
  g.beginPath();
  for (let i = 0; i < 6; i++){
    const a = ROT + i * (Math.PI / 3);  // nervios hacia los vÃ©rtices
    g.moveTo(0, 0);
    g.lineTo(
	 Math.cos(a) * r * 0.78,
	 Math.sin(a) * r * 0.78 * SY
   );

  }
  g.stroke();

  // Puntito central
  g.fillStyle = "rgba(255,255,255,0.14)";
  g.fillRect(0, 0, 1, 1);

  // Notch asimÃ©trico
  g.fillStyle = "rgba(0,0,0,0.22)";
  g.fillRect((r*0.40)|0, (-r*0.55)|0, 2, 1);

  g.restore();
}

// 2) Helper: brazo tubo simple (mÃ¡s ancho) + highlight
function tube(g, x0, y0, x1, y1){
  // Tronco (mÃ¡s ancho)
  g.strokeStyle = "rgba(0,0,0,0.55)";
  g.lineWidth = 4;
  g.beginPath();
  g.moveTo(x0, y0);
  g.lineTo(x1, y1);
  g.stroke();

  // Highlight (1px)
  g.strokeStyle = "rgba(255,255,255,0.10)";
  g.lineWidth = 1;
  g.beginPath();
  g.moveTo(x0, y0-1);
  g.lineTo(x1, y1-1);
  g.stroke();
}

for (let f = 0; f < 2; f++){
  const [c,g] = mk(44, 30);
  g.clearRect(0, 0, 44, 30);

  // --- Layout ---
  const cx = 22, cy = 15;

  // Alas (cruce sutil para efecto 3D)
  const wingR = 9;
  const Lcx = 10, Lcy = 15;   // ala izq un poco a la derecha (DETRÃS)
  const Rcx = 34, Rcy = 15;   // ala der un poco a la izquierda (DELANTE)

  // Cabina (dos cÃ­rculos)
  const rOut = 6;
  const rIn  = 4;

  // =========================
  // 1) IZQUIERDA DETRÃS
  // =========================
  
    // ala izq detrÃ¡s
  tieHexLikeWreck(g, Lcx, Lcy, wingR);
  // brazo izq detrÃ¡s (mÃ¡s abajo)
  tube(g, cx - rOut + 1, cy - 0, Lcx -1, Lcy -1);


  // =========================
  // 2) COCKPIT EN MEDIO
  // =========================
  // exterior
  for (let yy = -rOut; yy <= rOut; yy++){
    const dx = Math.floor(Math.sqrt(rOut*rOut - yy*yy));
    px(g, cx - dx, cy + yy, dx*2 + 1, 1, "#9ca3af");
  }
	const cxi = cx - 2; // centro interior desplazado a la izquierda

	// interior
	for (let yy = -rIn; yy <= rIn; yy++){
	  const dx = Math.floor(Math.sqrt(rIn*rIn - yy*yy));
	  px(g, cxi - dx, cy + yy, dx*2 + 1, 1, "#6b7280");
	}

	// brillo (tambiÃ©n desplazado)
	px(g, cxi - 1, cy - 1, 2, 2, "rgba(255,255,255,.12)");

  // =========================
  // 3) DERECHA DELANTE
  // =========================
  
    // brazo der delante (ligeramente mÃ¡s alto para â€œpor delanteâ€)
  tube(g, cx + rOut - 1, cy + 0, Rcx - 1, Rcy + 0);
  // ala der delante
  tieHexLikeWreck(g, Rcx, Rcy, wingR);


  // Disparo rojo en frame 2
  if (f === 1){
    px(g, 17, 15, 2, 1, "rgba(255,77,77,.75)");
    px(g, 25, 15, 2, 1, "rgba(255,77,77,.75)");
  }

  outline(g, "#0b1020");
  tie.push(c);
}



  // Asteroides
  function makeAsteroidSprite(size, variant){
  // Pixel-art asteroid (no gradients): irregular but rounded silhouette + 3-tone palette + simple dithering.
  // Render at low-res then upscale with smoothing OFF for chunky pixels.
  const low = Math.max(24, (size/2)|0);     // e.g. 64->32, 44->24
  const [cl, gl] = mk(low, low);
  gl.clearRect(0,0,low,low);
  gl.imageSmoothingEnabled = false;

  const rnd = mulberry32(0xA53C9E + variant*0x1F123BB);
  const cx = low/2, cy = low/2;

  // --- Build a rounded irregular path (quadratic midpoints) ---
  const pts = 28;
  const baseR = low * (0.34 + 0.02*rnd());
  const jitter = low * 0.065;

  const P = [];
  for (let i=0;i<pts;i++){
    const a = (i/pts) * Math.PI*2;
    const rr = baseR + (rnd()*2-1)*jitter + (Math.sin(a*3 + rnd()*2)*jitter*0.18);
    P.push([ cx + Math.cos(a)*rr, cy + Math.sin(a)*rr ]);
  }

  gl.beginPath();
  for (let i=0;i<pts;i++){
    const p0 = P[i];
    const p1 = P[(i+1)%pts];
    const mx = (p0[0]+p1[0])*0.5;
    const my = (p0[1]+p1[1])*0.5;
    if (i===0) gl.moveTo(mx,my);
    gl.quadraticCurveTo(p0[0],p0[1],mx,my);
  }
  gl.closePath();

  // Palette (highlight / mid / shade)
  const pal = variant
    ? ["#8c95a5", "#5f6878", "#2d3340"]
    : ["#96a0b2", "#69738a", "#2a3242"];

  // 4x4 Bayer matrix for ordered dithering
  const bayer4 = [
    [ 0,  8,  2, 10],
    [12,  4, 14,  6],
    [ 3, 11,  1,  9],
    [15,  7, 13,  5]
  ];

  // Draw pixels by testing inside the path (robust, no ImageData needed)
  for (let y=0;y<low;y++){
    for (let x=0;x<low;x++){
      if (!gl.isPointInPath(x+0.5,y+0.5)) continue;

      // Light from top-left
      const nx = (x - cx) / (baseR*1.10);
      const ny = (y - cy) / (baseR*1.10);
      let s = 0.58 - (nx*0.55 + ny*0.75);
      s = Math.max(0, Math.min(1, s));

      const t = (bayer4[y&3][x&3]/16) - 0.5;
      let idx;
      if (s > 0.70 + t*0.10) idx = 0;
      else if (s > 0.44 + t*0.10) idx = 1;
      else idx = 2;

      gl.fillStyle = pal[idx];
      gl.fillRect(x,y,1,1);
    }
  }

  // Speckles
  for (let n=0;n<140;n++){
    const x = (rnd()*low)|0;
    const y = (rnd()*low)|0;
    if (!gl.isPointInPath(x+0.5,y+0.5)) continue;
    gl.fillStyle = (rnd()<0.5) ? "rgba(255,255,255,.35)" : "rgba(0,0,0,.35)";
    gl.fillRect(x,y,1,1);
  }

  // Pixel craters (rings)
  for (let k=0;k<6;k++){
    let px=0, py=0, tries=0;
    while (tries++ < 30){
      px = (rnd()*low)|0;
      py = (rnd()*low)|0;
      if (gl.isPointInPath(px+0.5, py+0.5)) break;
    }
    const cr = 2 + ((rnd()*4)|0); // 2..5
    for (let yy=-cr-1; yy<=cr+1; yy++){
      for (let xx=-cr-1; xx<=cr+1; xx++){
        const rr = Math.hypot(xx,yy);
        const x = px+xx, y = py+yy;
        if (x<0||y<0||x>=low||y>=low) continue;
        if (!gl.isPointInPath(x+0.5,y+0.5)) continue;

        if (rr > cr+0.6) continue;
        if (rr > cr-0.2) { gl.fillStyle = "rgba(0,0,0,.35)"; gl.fillRect(x,y,1,1); }        // ring
        else if (rr < cr*0.55) { gl.fillStyle = "rgba(255,255,255,.10)"; gl.fillRect(x,y,1,1); } // inner
      }
    }
    // slight shadow bottom-right
    gl.fillStyle = "rgba(0,0,0,.18)";
    gl.fillRect(px+1, py+1, 1, 1);
  }

  // Outline (low-res) to read on space background
  outline(gl, "#0b1020");

  // Upscale to final size with no smoothing
  const [c,g] = mk(size,size);
  g.clearRect(0,0,size,size);
  g.imageSmoothingEnabled = false;
  g.drawImage(cl, 0,0, low,low, 0,0, size,size);
  outline(g, "#0b1020");
  return c;
}

  const asteroidA = makeAsteroidSprite(32, 0);
  const asteroidB = makeAsteroidSprite(32, 1);

  // OJO: no devolvemos "falcon" (se dibuja con falconImg)
  return { engine, tie, asteroidA, asteroidB };
}

function loop(t){
    const dt = Math.min(0.033, (t - lastT)/1000);
    lastT = t;
	
	  // âœ… esto SIEMPRE, incluso en game over
	updateParticles(dt);
	updateDebrisAndWrecks(dt);
	
	if (!canRestart) {
	  restartTimer -= dt;
	 if (restartTimer <= 0) {
		canRestart = true;
	  }
	}

    if (running && !gameOver) update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
